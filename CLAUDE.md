
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Common Development Commands

### Running the Application
```bash
# Start Expo development server
npm start

# Run on specific platforms
npm run ios      # iOS Simulator
npm run android  # Android Emulator
npm run web      # Web browser
```

### AWS Amplify Commands
```bash
# Initialize Amplify (first-time setup)
amplify init

# Deploy backend changes
amplify push

# Pull latest backend configuration
amplify pull

# Check Amplify status
amplify status
```

### Development Workflow
```bash
# Install dependencies
npm install

# Clear Expo cache (for build issues)
expo start -c

# Install specific Expo packages
expo install [package-name]
```

### Package Manager Policy
**This project uses npm exclusively.** Do not use yarn to avoid lockfile conflicts.

```bash
# ✅ Correct - Use npm
npm install           # Install dependencies
npm install package   # Add new dependency
npm audit fix         # Fix vulnerabilities

# ❌ Avoid - Do not use yarn
yarn install          # Creates conflicting yarn.lock
yarn add package      # Mixed package managers
```

## Architecture Overview

### Tech Stack
- **Frontend**: React Native with Expo (managed workflow)
- **Backend**: AWS Amplify with GraphQL API
- **Audio**: Expo AV for recording and playback
- **State Management**: React Context API
- **Navigation**: React Navigation v6

### AWS Services Integration
The app heavily relies on AWS Amplify for backend services:
- **Authentication**: AWS Cognito user pools
- **API**: GraphQL with AWS AppSync (schema at `amplify/backend/api/littlebitgraphqlAPI/schema.graphql`)
- **Storage**: S3 for audio files (configured in `amplify/backend/storage/`)
- **Database**: DynamoDB (managed through GraphQL)
- **Functions**: Lambda functions in `amplify/backend/function/`
  - `CreateSampleRecord` (Node.js): Creates database records + triggers ECS audio processing
  - `EditandConvertRecordings` (Python 3.8): Legacy function (replaced by ECS in production)
- **Container Processing**: ECS Fargate for scalable audio processing
  - Production audio processing via `amplify/backend/custom/ecs/audio-processing/`
  - PyDub-based intelligent audio cropping with configurable parameters

### Key Application Flows

1. **Audio Recording Flow** (ECS-Based Production Pipeline):
   - User initiates recording in `RecorderScreen`
   - Audio captured using Expo AV APIs
   - Recording saved to S3 `public/unprocessed/{userID}/` via Amplify Storage
   - S3 trigger → `CreateSampleRecord` Lambda (creates database record with `processing_status: PENDING`)
   - `CreateSampleRecord` → triggers ECS Fargate task for audio processing
   - ECS container processes audio with PyDub `split_on_silence` functionality
   - Processed files saved to S3 `public/processed/{userID}/`
   - Database updated with `processing_status: COMPLETED/FAILED` and processing timestamps
   - Real-time status tracking available via GraphQL subscriptions

2. **Authentication Flow**:
   - Managed by `UserContext` using AWS Cognito
   - Sign up includes email verification
   - Protected routes require authentication

3. **Data Flow**:
   - GraphQL subscriptions for real-time updates
   - Optimistic UI updates for better UX
   - S3 presigned URLs for secure audio access

### Critical Files and Patterns

- **API Services** (`src/api/`): Encapsulate Amplify operations
  - `auth.js`: Cognito authentication wrapper (comprehensive test coverage: 18/18 tests)
  - `playback.js`: Audio playback management (robust error handling, supports play/pause/resume/restart)
  - `sounds.js`: CRUD operations for audio samples

- **GraphQL Operations** (`src/graphql/`): Auto-generated by Amplify
  - Mutations, queries, and subscriptions for Sample model with processing status tracking
  - Enhanced Sample model includes: `processing_status`, `processing_started_at`, `processing_completed_at`, `processing_error`, `processing_params`
  - Custom resolvers may be in `amplify/backend/api/littlebitgraphqlAPI/resolvers/`

- **Screen Components**: Each screen in `src/screens/` is self-contained
  - Use hooks from `src/hooks/` for shared logic
  - Import reusable components from `src/components/`
  - `Sounds.js`: Complex audio playback state management with optimistic UI updates

### Development Considerations

1. **Permissions**: Audio recording requires microphone permissions (handled automatically by Expo)

2. **Platform Differences**: 
   - Web platform has limited audio features
   - iOS requires special handling for silent mode (`playsInSilentMode`)

3. **AWS Configuration**:
   - `src/aws-exports.js` is auto-generated and contains sensitive config
   - Never commit AWS credentials or modify aws-exports.js manually

4. **Model Changes**: 
   - GraphQL schema changes require `amplify push` to update
   - This regenerates models in `src/models/`

5. **State Management**:
   - UserContext provides global auth state
   - Local component state for UI interactions
   - No Redux or MobX - keep state management simple
   - Audio playback uses optimistic UI updates with error recovery

### Testing and Code Quality

**Current Status**: 
- Jest and React Native Testing Library configured for unit and component testing
- Test coverage reporting with CodeCov integration
- GitHub Actions workflow for automated testing on PRs
- No linting rules beyond basic `.eslintignore`
- No TypeScript setup

**Testing Commands**:
```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage report
npm run test:coverage

# Run tests for CI/CD
npm run test:ci
```

**Testing Structure**:
- Tests are located in `__tests__` directories adjacent to the code they test
- Test files should follow the naming convention: `*.test.js` or `*.spec.js`
- Jest configuration is in `jest.config.js`
- Test setup and mocks are in `jest.setup.js`

**Writing Tests**:
```javascript
// Example component test
import { render, fireEvent } from '@testing-library/react-native';
import MyComponent from '../MyComponent';

test('should handle user interaction', () => {
  const { getByText } = render(<MyComponent />);
  fireEvent.press(getByText('Button'));
  expect(getByText('Result')).toBeTruthy();
});
```

**Mocking Guidelines**:
- AWS Amplify services are pre-mocked in `jest.setup.js`
- Expo AV (audio) modules are mocked for testing
- React Navigation hooks are mocked
- Use `jest.mock()` for additional module mocking as needed

**Coverage Goals**:
- Target 80%+ code coverage for new features
- Coverage reports are generated in `/coverage` directory
- View HTML coverage report: `open coverage/lcov-report/index.html`

### Troubleshooting Guide

#### Common Development Issues

1. **Metro Bundler Problems**:
   ```bash
   # Clear all caches
   npx expo start -c
   
   # Reset everything
   rm -rf node_modules
   npm install
   npx expo start -c
   ```

2. **AWS Amplify Sync Issues**:
   ```bash
   # Pull latest backend config
   amplify pull --restore
   
   # Check backend status
   amplify status
   
   # View function logs
   amplify logs
   ```

3. **Audio Recording Issues**:
   - iOS: Check Settings > Privacy > Microphone
   - Android: Verify permissions in app settings
   - Web: HTTPS required for microphone access

4. **Audio Playback Issues**:
   - If samples won't play from the list, check `src/screens/Sounds.js` state management
   - Play/pause icon inconsistencies may indicate `soundObj` state sync issues
   - For debugging: Enable console logs in `handleAudioPress` and `onPlaybackStatusUpdate`
   - Audio restart problems often relate to `positionMillis` not being reset to 0

### Security Considerations

- **Vulnerabilities**: Check `/docs/dependency-vulnerabilities.md` for known issues
- **AWS Credentials**: Never commit credentials - use `aws-exports.js` (auto-generated)
- **Environment Variables**: Currently not used, but would go in `.env` files

### Project Structure Details

#### Key Configuration Files
- `/metro.config.js` - Excludes Amplify cloud backend from bundling
- `/babel.config.js` - Uses Expo preset
- `/src/amplifyconfiguration.json` - Amplify service configuration
- `/ISSUE_TEMPLATE.md` - Template for bug reports

#### CI/CD Workflows
- `.github/workflows/claude.yml` - Claude Code AI assistant
- `.github/workflows/claude-code-review.yml` - Automated PR reviews
- `.github/workflows/test.yml` - Automated test suite runs on PRs and pushes

### Expo-Specific Tips

```bash
# Run on specific port
npx expo start --port 8081

# Open developer menu
# iOS Simulator: Cmd + D
# Android Emulator: Cmd + M

# Install Expo-compatible versions
expo install [package-name]  # Ensures compatibility
```

### Version Requirements

- **Node.js**: 14+ (recommend 18+ LTS)
- **Expo SDK**: 53 (latest)
- **React Native**: 0.79.5
- **AWS Amplify**: v6 (migrated from v4)

### Development Best Practices

1. **Before Committing**:
   - Run `npm audit` for security checks
   - Ensure no AWS credentials in code
   - Test on both iOS and Android if possible

2. **When Adding Dependencies**:
   - Use `npm install` (not yarn)
   - Use `expo install` for Expo-compatible packages
   - Update `package-lock.json`

3. **GraphQL Schema Changes**:
   - Edit schema in `amplify/backend/api/littlebitgraphqlAPI/schema.graphql`
   - Run `amplify push` to deploy changes
   - This regenerates TypeScript models in `src/models/`

### Recent Improvements (2025-07-17)

#### Audio Playback System Overhaul
**Issue Resolved**: #39 - Sample audio playback functionality in sample list

**Key Improvements Made**:
- **Robust State Management**: Fixed null reference crashes and state synchronization issues
- **UI Consistency**: Proper play/pause icon states that reflect actual audio status
- **Complete Playback Cycle**: Supports play → pause → resume → restart from finish
- **Error Recovery**: Comprehensive error handling with optimistic UI updates and rollback
- **Input Validation**: Security improvements with parameter validation
- **Memory Safety**: Proper cleanup considerations documented

**Technical Implementation**:
- **File**: `src/screens/Sounds.js` - Complete rewrite of audio state management
- **Callback System**: Stable `onPlaybackStatusUpdate` using `useRef` pattern
- **Fallback Detection**: Backup state synchronization using `getStatusAsync()`
- **Optimistic Updates**: Immediate UI feedback with error recovery
- **State Helpers**: `isEffectivelyPlaying()` and `isAudioFinished()` utilities

**Testing**: All 177 existing tests pass + comprehensive error handling

**Follow-up Issues Created**:
- **Issue #41**: Refactor `handleAudioPress` function complexity for better maintainability
- **Issue #42**: Add component unmount cleanup for audio objects (memory leak prevention)

**PR Reference**: #40 - Comprehensive audio playback state management fix

### Recent Improvements (2025-07-18)

#### Audio Processing Pipeline Implementation
**Issue Resolved**: #48 - Fix audio processing pipeline Lambda function chaining and quality verification

**Problem Solved**: 
The audio processing pipeline was completely broken - uploaded audio files remained unprocessed in S3 because the Lambda function chaining wasn't working.

**Key Fixes Implemented**:
- **Lambda Function Chaining**: Fixed `CreateSampleRecord` → `EditandConvertRecordings` invocation
- **Missing Dependencies**: Added `aws-sdk` dependency to `CreateSampleRecord` (Node.js 18.x runtime doesn't include it)
- **Environment Variables**: Added `FUNCTION_EDITANDCONVERTRECORDINGS_NAME` for proper function resolution
- **Security Hardening**: Comprehensive input validation, path traversal protection, and error handling
- **Future Architecture**: Simplified Lambda processing with clear ECS migration path

**Pipeline Flow (Now Working)**:
1. User uploads audio → `public/unprocessed/{userID}/{filename}`
2. S3 trigger → `CreateSampleRecord` (creates database record)
3. `CreateSampleRecord` → invokes `EditandConvertRecordings` (processes audio)
4. `EditandConvertRecordings` → creates processed files in `public/processed/{userID}/`
5. Debug files created in `debug/` directories for quality tracking

**Technical Implementation**:
- **File**: `amplify/backend/function/CreateSampleRecord/src/index.js` - Added Lambda invocation logic
- **File**: `amplify/backend/function/EditandConvertRecordings/src/index.py` - Security-hardened minimal processing
- **Security Features**: UUID-based session IDs, input validation, retry logic, resource cleanup
- **Architecture Decision**: Minimal Lambda processing (file copying) to establish pipeline foundation

**Security Improvements Added**:
- Path traversal protection (`..` detection in S3 keys)
- Username/filename regex validation with length limits
- S3 operation retry logic with exponential backoff
- Disk space monitoring (100MB minimum requirement)
- Structured error responses (400 vs 500 status codes)
- Automatic cleanup of temporary files

**Future Migration Path**: 
The current implementation provides a foundation for migrating to ECS/Fargate for advanced audio processing (compression, effects, etc.). The `EditandConvertRecordings` function can be updated to trigger ECS tasks for complex operations.

**Testing**: All 184 tests pass + comprehensive error handling validation

**PR Reference**: #49 - Complete audio processing pipeline with Lambda function chaining and security improvements

### Recent Improvements (2025-07-20)

#### ECS Audio Processing Container Development (Phase 2)
**Issue Resolved**: #62 - ECS Audio Processing Container Development with Security Hardening

**Problem Solved**: 
Developed production-ready ECS container to replace Lambda-based audio processing, enabling advanced PyDub functionality and unlimited processing time while maintaining comprehensive security.

**Key Features Implemented**:
- **PyDub Integration**: Complete `split_on_silence` functionality restored with configurable parameters
- **Security Hardening**: Comprehensive input validation, path traversal protection, metadata sanitization
- **S3 Operations**: Secure download/upload with retry logic and exponential backoff with jitter
- **Error Handling**: Thread-safe cleanup, categorized errors, comprehensive recovery mechanisms
- **CloudWatch Logging**: Structured JSON logging with performance metrics and session tracking

**Technical Implementation**:
- **Container**: Python 3.11-slim with FFmpeg, PyDub, librosa, comprehensive audio libraries
- **Security**: Non-root execution, input validation framework, resource monitoring
- **Processing**: Configurable silence detection (-50 to -20 dBFS), intelligent audio analysis
- **Integration**: Environment variable configuration, structured responses for Lambda integration

**File Structure**:
```
amplify/backend/custom/ecs/audio-processing/
├── audio_processor.py          # Main processing service with security hardening
├── s3_operations.py            # Secure S3 operations with retry logic  
├── utils/
│   ├── input_validation.py     # Comprehensive input validation framework
│   ├── error_handlers.py       # Categorized error handling and recovery
│   ├── logging_config.py       # CloudWatch logging configuration
│   └── audio_utils.py         # Audio processing utilities and configuration
├── tests/                      # Comprehensive test suite
├── DEPLOYMENT_CHECKLIST.md    # Production deployment validation guide
└── deployment_validation.py   # Automated validation framework
```

**Security Enhancements**:
- Path traversal protection with `os.path.normpath()` and multi-vector detection
- Input validation with regex patterns for user IDs, S3 keys, filenames
- Metadata sanitization preventing CloudWatch injection attacks
- Thread-safe cleanup preventing race conditions
- Retry jitter preventing thundering herd problems

**Performance Targets**:
- Container startup: <30 seconds (cold start)
- Processing time: <2 minutes for 30-second recordings  
- Memory usage: <1.5GB per task
- Success rate: >99% processing completion

**Integration Ready**: 
Ready for Phase 3 Lambda-ECS integration (Issue #63) with environment variable configuration, structured responses, and comprehensive monitoring.

**Testing**: All 184 tests pass + comprehensive security validation (6/6 validation checks)

**PR Reference**: #67 - Phase 2 ECS Audio Processing Container Development with Security Hardening

#### Lambda-ECS Integration (Phase 3)
**Issue Resolved**: #63 - Phase 3: Lambda-ECS Integration for Audio Processing Pipeline

**Problem Solved**: 
Complete the transition from Lambda-based to ECS-based audio processing by integrating the existing S3-triggered Lambda function with the new ECS Fargate containers.

**Key Features Implemented**:
- **GraphQL Schema Enhancement**: Added processing status tracking with `ProcessingStatus` enum (PENDING/PROCESSING/COMPLETED/FAILED)
- **Lambda-ECS Integration**: Modified `CreateSampleRecord` to trigger ECS tasks instead of Lambda functions
- **Real-time Status Tracking**: Database updates throughout processing workflow with timestamps and error details
- **Security Hardening**: Scoped IAM permissions to specific ECS resources following least privilege principle
- **Robust Error Handling**: HTTP 202 responses for async processing, comprehensive status rollback on failures

**Technical Implementation**:
- **Database Schema**: Enhanced Sample model with 5 new processing status fields
- **Lambda Function**: `amplify/backend/function/CreateSampleRecord/src/index.js` - Complete ECS integration
- **IAM Security**: Permissions scoped to specific cluster and task definition ARNs
- **Environment Validation**: Comprehensive configuration validation preventing runtime failures
- **Race Condition Fixes**: Status updates only after successful ECS task launch

**Integration Flow (Production Pipeline)**:
1. **S3 Upload** → Triggers CreateSampleRecord Lambda
2. **Database Record** → Created with `processing_status: PENDING` 
3. **ECS Task Launch** → Fargate task triggered with processing parameters
4. **Status Updates** → Real-time tracking via GraphQL mutations
5. **Error Handling** → Automatic status rollback on failures

**Security Improvements**:
- IAM permissions scoped from `"Resource": "*"` to specific ARNs
- Environment variable validation preventing placeholder deployments
- Enhanced error handling without exposing system internals
- Comprehensive input validation and path traversal protection

**Performance & Reliability**:
- ECS task startup validation before status updates (eliminates race conditions)
- HTTP 202 responses for proper async operation semantics
- Environment configuration validation preventing runtime failures
- All 184 existing tests pass + new integration capabilities

**Architecture Benefits**:
- **Unlimited Processing Time**: No 15-minute Lambda constraint
- **Scalable Resources**: Up to 30GB RAM, 4 vCPU per task
- **Advanced Audio Libraries**: Full PyDub, librosa, FFmpeg support
- **Cost Efficient**: Pay-per-processing-task model
- **Future Ready**: Foundation for AI-powered audio analysis

**Integration Ready**: 
Enables Phase 4 UI Integration (#64) for user-configurable processing parameters and real-time status monitoring.

**Testing**: All 184 tests pass + comprehensive code review security fixes

**PR Reference**: #68 - Phase 3 Lambda-ECS Integration for Audio Processing Pipeline